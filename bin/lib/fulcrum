#!/bin/bash

source ${FULCRUM_BINDIR}/lib/general

function usage() {
  echo "Example Usage: "
  echo " -h  Help"
  echo " -n  No docker pull (default)"
  echo " -p  Do docker pull (update your images)"
  echo " -q  quiet"
  echo " -s  sudo - if you cannot run 'docker' without sudo, pass this flag"
  echo " -v  verbose (debug)"
  echo " -x  turn 'set -x' on (deep debug)"
  echo ""
  echo "up             - restart all containers, also use to start them [start] [restart] [reload]"
  echo "stop           - stop all containers and remove them [stop] [halt] [down] [shutdown]"
  echo "sh             - step inside a running container [sh] [bash] [shell] [enter] [dsh] [dbash]"
  echo "ps             - show containers (running or stopped) [dps]"
  echo "log            - show logs being put out from containers, ctrl+C to stop following [log] [logs] [dlog] [dlogs]"
  echo "haproxyrestart - restart haproxy, for when modifying the config [haproxy] [haproxy-restart]"
  echo "conf           - regenerate nginx .conf file from json [nginx] [nginx-restart]"
  echo "ocfl           - flush Zend OPcache [opcacheflush]"
  echo "ocof           - disable Zend OPcache [ocoff] [opcacheoff]"
  echo "ocon           - enable Zend OPcache [opcacheon]"
  echo "ocst           - status of Zend OPcache [opcachestatus]"
  echo "etch           - add a 127.0.0.1 host to etc/hosts [etchost] [etchosts]"
  echo "rnd            - create a random string, will be prompted for length [rand] [random] [randomstr]"
  echo "sc             - create a self-signed HTTPS certificate [signcert]"
  echo "fs             - force HTTPS via base_url [forcehttps]"
  echo ""
  echo "This requires Docker for Mac or Windows, please get the stable version from https://docs.docker.com/"
  exit 0
}

# show container status
function dps() {
  docker-compose --file "${DCFILE}" ps
  exit 0
}

# show container logs
function dlogs() {
  sendalert "We are following the logs of the containers, Ctrl+C to stop"
  docker-compose --file "${DCFILE}" logs -f
  exit 0
}

function stopAllContainers() {
  # this trick helps kill everything in the event compose file changes and it doesn't really stop everything
  RUNNING_CONTAINERS=$(docker ps -q | wc -l)
  if [ $RUNNING_CONTAINERS -gt 0 ]; then
    sendalert "stopping any running containers"
    docker stop $(docker ps -q) 1>/dev/null
  fi
}

function rmAllContainers() {
  STOPPED_CONTAINERS=$(docker ps -a -q | wc -l)
  if [ $STOPPED_CONTAINERS -gt 0 ]; then
    sendalert "killing any stopped containers"
    docker rm -f $(docker ps -a -q) 1>/dev/null
  fi
}

function stopAndRmAllContainers() {
  stopAllContainers

  rmAllContainers
}

function dStop() {
  stopAndRmAllContainers
}

# start/restart all our containers
function drestart() {
  # run d4m-nfs in order to allow using NFS volume mounts
  if [[ "$FULCRUM_OS" == "MAC" ]]; then
    ~/fulcrum/var/fulcrum/d4m-nfs/d4m-nfs.sh -q
  fi

  stopAndRmAllContainers

  if [ $DOPULL -eq 1 ]; then
    vout "doing docker pull"
    sendalert "doing docker pull, if you get an error about \"TLS handshake timeout\", then re-run this same command again"
    docker-compose --file "${DCFILE}" pull
    docker pull fulcrum/util
  else
    vout "skipping docker pull"
    sendalert "skipping docker image pull, add -p flag if you wish to pull next time"
  fi

  vout "starting containers"
  sendalert "Starting containers"
  if [ $QUIET -eq 1 ]; then
    vout "quiet docker-compose up"
    docker-compose --file "${DCFILE}" up -d 1>/dev/null 2>/dev/null
  else
    vout "verbose docker-compose up"
    docker-compose --file "${DCFILE}" up -d
  fi

  waitForDB

  helloSites
}

# mariadb has a ready for connections twice,
# so we have to wait until there is only 1 root user
# until everything is setup and we can use it
function waitForDB() {
  mkdir -p $FULCRUM_DIRNAME/var/fulcrum/tmp
  ROOT_COUNT=$FULCRUM_DIRNAME/var/fulcrum/tmp/count

  echo -n "-1" > $ROOT_COUNT

  echo -n "Waiting until database is available."
  while ! (docker exec mariadb mysql -sN -e "SELECT COUNT(*) FROM mysql.user where user = 'root'" 2> /dev/null 1> $ROOT_COUNT) || [ "$(cat $ROOT_COUNT)" != "1" ] ; do
    echo -n "."
    sleep .25
  done

  rm $ROOT_COUNT
  echo ""
}

function helloSites() {
  FULCRUM_INI="$FULCRUM_DIRNAME/etc/fulcrum/fulcrum.ini"

  # if $FULCRUM_INI doesn't exist or hello7_site doesn't exist in $FULCRUM_INI
  if [ ! -e "$FULCRUM_INI" ] || ! $(grep hello7_site $FULCRUM_INI > /dev/null 2>&1); then
    vout "Creating Hello Fulcrum 7 site"
    mkdir -p $(dirname $FULCRUM_INI)

    $FULCRUM_BINDIR/site hello7.fulcrum.ifdev \
      $FULCRUM_DIRNAME/var/fulcrum/bak/hello7.sql.gz \
      hello7dev git@github.com:if-fulcrum/hello7.git

    echo "hello7_site = 7.52" >> $FULCRUM_INI
  fi

  # if $FULCRUM_INI doesn't exist or hello8_site doesn't exist in $FULCRUM_INI
  if [ ! -e "$FULCRUM_INI" ] || ! $(grep hello8_site $FULCRUM_INI > /dev/null 2>&1); then
    vout "Creating Hello Fulcrum 8 site"
    mkdir -p $(dirname $FULCRUM_INI)

    $FULCRUM_BINDIR/site hello8.fulcrum.ifdev \
      $FULCRUM_DIRNAME/var/fulcrum/bak/hello8.sql.gz \
      hello8dev git@github.com:if-fulcrum/hello8.git docroot

    echo "hello8_site = 8.2.3" >> $FULCRUM_INI
  fi
}

# step into docker container
function dbash() {
  FULCRUM_OS_INT_PREFIX=""
  if [[ "$FULCRUM_OS" == "WIN" ]]; then
    FULCRUM_OS_INT_PREFIX="winpty "
  fi

  DOCKER_IMAGES=$(docker ps --format '{{.Names}}' | sort | awk '{ print FNR " " $0 }')
  echo "$DOCKER_IMAGES"
  read -p "Please enter container number to enter: " MYNUMBER
  ENTER_IMAGE=$(echo "$DOCKER_IMAGES" | awk -v MYNUMBER=${MYNUMBER} '$1 == MYNUMBER { print $2 }')

  echo "${ENTER_IMAGE}"
  # https://github.com/docker/docker/issues/9299
  $FULCRUM_OS_INT_PREFIX docker exec -it ${ENTER_IMAGE} sh -c "export TERM=xterm; exec sh"
}

function opcacheFlush() {
  docker exec phpfpm sh -c 'kill -USR2 1'
  vout "Zend OPcache Flushed"
}

function opcacheOff() {
  echo "opcache.enable=0" > $FULCRUM_DIRNAME/etc/php5/conf.d/zz-opcache-overide.ini
  vout "Zend OPcache Disabled"
  opcacheFlush
}

function opcacheOn() {
  echo "opcache.enable=1" > $FULCRUM_DIRNAME/etc/php5/conf.d/zz-opcache-overide.ini
  vout "Zend OPcache Enabled"
  opcacheFlush
}

function opcacheStatus() {
  OCMODE=$(cat $FULCRUM_DIRNAME/etc/php5/conf.d/zz-opcache-overide.ini)

  if [[ "$OCMODE" == *"opcache.enable=1"* ]]; then
    vout "Zend OPcache status appears to be *enabled* ($OCMODE)"
  elif [[ "$OCMODE" == *"opcache.enable=0"* ]]; then
    vout "Zend OPcache status appears to be *disabled* ($OCMODE)"
  else
    vout "Zend OPcache status is unknown ($OCMODE)"
  fi
}

function etcHosts127() {
  read -p "Please enter hostname your would like to map to 127.0.0.1: " ETCHOST
  etcHosts 127.0.0.1 $ETCHOST
}

function rndStrInput() {
  read -p "Please enter the number random characters: " CHARCOUNT
  rndStr $CHARCOUNT
}

function forcehttps() {
  # see if we were given a domain
  DOMAIN=${1:-""}

  # ask if we didn't fine a domain
  if [ -z "$DOMAIN" ]; then
    read -p "Please enter hostname your would like force https: " DOMAIN
  fi

  CONF_FILE=$FULCRUM_DIRNAME/etc/fulcrum/conf/$DOMAIN.json
  if [ ! -e $CONF_FILE ]; then
    eout "Cannot find $DOMAIN ($CONF_FILE)"
  fi

  # remove any previous base_url
  grep -v force_https $CONF_FILE | grep -v base_url > $CONF_FILE.bak

  # add in force_https
  perl -p -i -e "s#(webroot.*?,)#\$1\\n  \"force_https\" : \"true\",#" $CONF_FILE.bak

  # add in base_url
  perl -p -i -e "s#(cookie_domain.*?,)#\$1\\n      \"base_url\" : \"https://$DOMAIN\",#" $CONF_FILE.bak

  mv $CONF_FILE.bak $CONF_FILE

  nginxConfAll

  opcacheFlush
}
